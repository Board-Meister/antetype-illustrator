// Generated by dts-bundle-generator v9.5.1

import { IBaseDef, ICore, IParentDef, IStart, Layout, Module, Modules, XValue, YValue } from '@boardmeister/antetype-core';
import { Herald } from '@boardmeister/herald';
import { StandardLonghandProperties } from 'csstype';

declare enum Event$1 {
	CALC = "antetype.illustrator.calc"
}
export interface ICalcEvent<T = Record<string, any>> {
	purpose: string;
	layerType: string;
	values: T;
}
export interface IGroupArgs {
	clip?: boolean;
	interaction?: "fixed" | "static";
	direction?: "row" | "column";
	wrap?: boolean;
	gap?: {
		vertical?: number;
		horizontal?: number;
	};
}
export interface IGroupDef extends IParentDef {
	group: IGroupArgs;
}
export declare type LineJoin = "round" | "bevel" | "miter";
export declare type FillStyle = any | boolean | CanvasGradient | CanvasPattern | string;
export interface ILine {
	means: "line";
	args: {
		x: XValue;
		y: YValue;
	};
}
export interface ICurve {
	means: "curve";
	args: {
		cp1x: XValue;
		cp1y: YValue;
		cp2x: XValue;
		cp2y: YValue;
		x: XValue;
		y: YValue;
	};
}
export interface IStroke {
	means: "stroke";
	args: {
		thickness?: XValue;
		fill?: FillStyle;
		lineJoin?: LineJoin;
		miterLimit?: XValue;
	};
}
export interface IBegin {
	means: "begin";
	args: {
		x: XValue;
		y: YValue;
	};
}
export interface IMove {
	means: "move";
	args: {
		x: XValue;
		y: YValue;
	};
}
export interface IClose {
	means: "close";
	args: object;
}
export interface LeanerFillColor {
	offset: number;
	color: string;
}
export interface LinearFillStyle {
	pos: {
		x: XValue;
		y: YValue;
	};
	size: {
		w: XValue;
		h: YValue;
	};
	colors: LeanerFillColor[];
}
export interface IFillLinear {
	type: "linear";
	style: LinearFillStyle;
}
export interface IFillDefault {
	type: "default";
	style: FillStyle;
}
export type FillTypes = IFillLinear | IFillDefault;
export interface IFill {
	means: "fill";
	args: FillTypes;
}
export type PolygonActions = ILine | ICurve | IStroke | IBegin | IMove | IClose | IFill;
export interface IPolygonArgs {
	steps: PolygonActions[];
	size: {
		negative: IStart;
		positive: IStart;
	};
}
export interface IPolygonDef<T = never> extends IBaseDef<T> {
	polygon: IPolygonArgs;
}
interface IImageCoords {
	xDiff: number;
	yDiff: number;
	width: number;
	height: number;
}
declare class CalculatedImage {
	image: HTMLImageElement;
	coords: IImageCoords;
	constructor(image: HTMLImageElement, coords: IImageCoords);
}
export type ImageFit = "stretch" | "crop" | "default";
export type ImageFitTo = "auto" | "height" | "width";
export type VerticalAlignType = "top" | "bottom" | "center";
export type HorizontalAlignType = "left" | "right" | "center";
export interface IImageAlign {
	vertical: VerticalAlignType;
	horizontal: HorizontalAlignType;
}
export interface IOutline {
	thickness: XValue;
	fill: FillTypes;
}
export interface IOvercolor {
	fill: FillTypes;
}
export interface IImageArg {
	calculated?: CalculatedImage | symbol;
	timeout?: number;
	fit?: ImageFit;
	overcolor?: IOvercolor;
	outline?: IOutline;
	align?: IImageAlign;
	fitTo?: ImageFitTo;
	src: string | HTMLImageElement;
}
export interface IImageDef<T = never> extends IBaseDef<T> {
	image: IImageArg;
}
declare type TextLines = {
	0: string;
	1: number;
}[];
export declare type VerticalAlign = "center" | "top" | "bottom";
export declare type HorizontalAlign = "center" | "left" | "right" | "justify";
export interface ITextAlign {
	vertical?: VerticalAlign;
	horizontal?: HorizontalAlign;
}
export interface ITextColumns {
	amount: number;
	gap: number;
}
export interface ITextFont {
	style?: StandardLonghandProperties["fontStyle"];
	family?: StandardLonghandProperties["fontFamily"];
	weight?: StandardLonghandProperties["fontWeight"];
	size?: StandardLonghandProperties["fontSize"] | number;
	stretch?: StandardLonghandProperties["fontStretch"];
	variant?: StandardLonghandProperties["fontVariant"];
	height?: StandardLonghandProperties["lineHeight"];
}
export interface ITextOutline {
	fill: FillTypes;
	thickness: XValue;
	lineJoin?: "round" | "bevel" | "miter";
	miterLimit?: number;
}
export interface ITextArgs {
	value: string;
	align?: ITextAlign;
	columns?: ITextColumns;
	font?: ITextFont;
	spacing?: number;
	textBaseline?: "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";
	wrap?: boolean;
	lineHeight?: XValue;
	color?: FillStyle | FillTypes;
	outline?: ITextOutline;
	// Calculated do not set!
	transY?: number;
	lines?: TextLines;
}
export interface ITextDef extends IBaseDef {
	text: ITextArgs;
}
interface ModulesWithCore extends Modules {
	core: ICore;
	illustrator?: IIllustrator;
}
interface IIllustrator extends Module {
	reset: () => void;
	clear: () => void;
	group: (def: IGroupDef) => void;
	polygon: (def: IPolygonDef) => void;
	image: (def: IImageDef) => void;
	text: (def: ITextDef) => void;
	calc: <T = Record<string, unknown>>(def: ICalcEvent) => Promise<T>;
	generateText: (value: string) => ITextDef;
	generateImage: (src: string | HTMLImageElement) => IImageDef;
	generatePolygon: (steps: PolygonActions[]) => IPolygonDef;
	generateGroup: (layout: Layout) => IGroupDef;
}
export declare class Illustrator implements IIllustrator {
	#private;
	constructor(canvas: HTMLCanvasElement | null, modules: ModulesWithCore, herald: Herald);
	reset(): void;
	clear(): void;
	groupCalc(def: IGroupDef, sessionId?: symbol | null): Promise<void>;
	group(def: IGroupDef): void;
	polygonCalc(def: IPolygonDef): Promise<void>;
	polygon({ polygon: { steps }, start: { x, y } }: IPolygonDef): void;
	imageCalc(def: IImageDef): Promise<void>;
	image(def: IImageDef): void;
	textCalc(def: ITextDef): Promise<void>;
	text(def: ITextDef): void;
	calc<T = Record<string, unknown>>(def: ICalcEvent): Promise<T>;
	generateText(value: string): ITextDef;
	generateImage(src: string | HTMLImageElement): IImageDef;
	generatePolygon(steps?: PolygonActions[]): IPolygonDef;
	generateGroup(layout: Layout): IGroupDef;
}
export declare const ID = "illustrator";
export declare const VERSION = "0.0.4";

export {
	Event$1 as Event,
};

export {};
