// Generated by dts-bundle-generator v9.5.1

import { StandardLonghandProperties } from 'csstype';
import React$1 from 'react';
import { RouteProps } from 'react-router-dom';

interface EntryConfig {
	source: string | object;
	namespace: string;
	name: string;
	version: string;
	arguments?: unknown[];
}
interface RegisterConfig {
	entry: EntryConfig;
	type: "scope" | "module";
	scope?: boolean;
	tags?: string[];
	requires?: string[];
	lazy?: boolean;
	asset?: {
		src: string;
	};
	resource?: {
		src: string;
	};
}
declare class CModule<T = any> {
	constructor(...args: unknown[]);
	inject?: (injections: T) => void;
}
type Module<T = any> = CModule<T> | Record<string, unknown>;
interface IModuleImportObject {
	default?: Module | ((...args: unknown[]) => void);
}
interface IModuleImport {
	config: RegisterConfig;
	module: IModuleImportObject | (() => Promise<Module>);
}
declare class _IInjectable<T = object> {
	constructor(...args: unknown[]);
	inject(injections: T): void;
	scope?(): Record<string, unknown>;
	static inject: Record<string, string>;
}
type IInjectable<T> = typeof _IInjectable<T>;
declare class Marshal {
	static version: string;
	renderCount: number;
	registered: Record<string, RegisterConfig>;
	loaded: Record<string, object>;
	tagMap: Record<string, IModuleImport[]>;
	scope: Record<string, unknown>;
	instanceMap: WeakMap<Module<any>, RegisterConfig>;
	constructor();
	addScope(name: string, value: unknown): void;
	render(): void;
	register(config: RegisterConfig): void;
	getModuleConstraint(config: RegisterConfig): string;
	get<Type>(key: string): Type | null;
	load(): Promise<void>;
	loadScopes(): Promise<Record<string, RegisterConfig>>;
	updateTagModules(): void;
	tagModules(moduleImport: IModuleImport): void;
	instantiateModule(moduleImport: IModuleImport): Module;
	mapInstance(config: RegisterConfig, module: Module): void;
	getMappedInstance(module: Module): RegisterConfig | undefined;
	loadDependencies(module: Module, config: RegisterConfig): Record<string, object> | undefined | false;
	isESClass(fn: unknown): boolean;
	orderModules(moduleRegistry: Record<string, RegisterConfig>): RegisterConfig[];
	generateLoadGroups(toSend: Record<string, RegisterConfig>): Promise<IModuleImport>[];
	isTag(string: string): boolean;
	import(source: string, addScope?: Record<string, unknown>): Promise<IModuleImportObject>;
	importModule(config: RegisterConfig): Promise<IModuleImportObject>;
	retrieveModulePromise(config: RegisterConfig): Promise<IModuleImport>;
	isObjectEmpty(obj: object): boolean;
}
declare class _ISubscriber {
	static subscriptions: Subscriptions;
}
type ISubscriber = typeof _ISubscriber;
type AmbiguousSubscription = string | Subscription | Subscription[] | EventHandler;
type EventHandler = (event: CustomEvent) => Promise<void> | void;
type Subscriptions = Record<string, AmbiguousSubscription>;
interface Subscription {
	method: string | EventHandler;
	priority?: number;
	constraint?: string | Module | null;
	index?: number;
}
interface ISubscriberObject {
	module: ISubscriber;
	config: RegisterConfig;
}
interface IEventRegistration {
	event: string;
	subscription: AmbiguousSubscription;
	constraint?: string | Module | null;
	sort?: boolean;
	symbol?: symbol | null;
}
interface IInjection extends Record<string, object> {
	subscribers: ISubscriberObject[];
	marshal: Marshal;
}
declare class Herald {
	#private;
	static inject: Record<string, string>;
	inject(injections: IInjection): void;
	dispatch(event: CustomEvent): Promise<void>;
	dispatchSync(event: CustomEvent): void;
	batch(events: IEventRegistration[]): () => void;
	register(event: string, subscription: AmbiguousSubscription, constraint?: string | Module | null, sort?: boolean, symbol?: symbol | null): () => void;
	unregister(event: string, symbol: symbol): void;
}
type PathProps = JSX.IntrinsicAttributes & RouteProps;
interface INavItem {
	node?: React$1.ReactNode;
	label?: string;
	link?: string;
	action?: (e: React$1.MouseEvent<HTMLElement>) => void;
	items?: INavItem[];
}
interface Injected extends Record<string, object> {
	marshal: Marshal;
	herald: Herald;
}
declare class Minstrel {
	#private;
	static inject: Record<string, string>;
	inject(injections: Injected): void;
	setRoute(props: PathProps): void;
	getRoutes(): PathProps[];
	getMenu(): INavItem[];
	addMenuItem(item: INavItem): void;
	setMenu(newMenu: INavItem[]): void;
	getModuleConfig(module: Module): RegisterConfig;
	getResourceUrl(module: Module, suffix: string): string;
	lazy(module: Module, suffix: string, props?: Record<string, any>): React$1.ReactNode;
	component<T>(module: Module, suffix: string, scope?: Record<string, any>): React$1.FC<T>;
	asset(module: Module, suffix: string): string;
}
declare type UnknownRecord = Record<symbol | string, unknown>;
interface ModulesEvent {
	modules: Modules;
	canvas: HTMLCanvasElement | null;
}
interface Module$1 {
}
interface Modules {
	[key: string]: Module$1 | undefined;
	core: ICore;
}
interface DrawEvent {
	element: IBaseDef;
}
interface CalcEvent {
	element: IBaseDef | null;
}
declare type XValue = number;
declare type YValue = XValue;
interface IStart {
	x: XValue;
	y: YValue;
}
interface ISize {
	w: XValue;
	h: YValue;
}
interface IArea {
	size: ISize;
	start: IStart;
}
interface IHierarchy {
	parent: IParentDef | null;
	position: number;
}
interface IBaseDef<T = never> {
	[key: symbol | string]: unknown;
	hierarchy?: IHierarchy;
	start: IStart;
	size: ISize;
	type: string;
	can?: {
		move?: boolean;
		scale?: boolean;
		remove?: boolean;
	};
	area?: IArea;
	data?: T;
}
interface IParentDef extends IBaseDef {
	layout: Layout;
}
interface IDocumentDef extends IParentDef {
	type: "document";
	base: Layout;
	start: {
		x: 0;
		y: 0;
	};
	size: {
		w: 0;
		h: 0;
	};
}
interface IFont {
	url: string;
	name: string;
}
interface ICore extends Module$1 {
	meta: {
		document: IDocumentDef;
	};
	clone: {
		definitions: (data: IBaseDef) => Promise<IBaseDef>;
		getOriginal: <T extends UnknownRecord = UnknownRecord>(object: T) => T;
		getClone: <T extends UnknownRecord = UnknownRecord>(object: T) => T;
	};
	manage: {
		markAsLayer: (layer: IBaseDef) => IBaseDef;
		add: (def: IBaseDef, parent?: IParentDef | null, position?: number | null) => void;
		addVolatile: (def: IBaseDef, parent?: IParentDef | null, position?: number | null) => void;
		move: (original: IBaseDef, newStart: IStart) => Promise<void>;
		resize: (original: IBaseDef, newSize: ISize) => Promise<void>;
		remove: (def: IBaseDef) => void;
		removeVolatile: (def: IBaseDef) => void;
		calcAndUpdateLayer: (original: IBaseDef) => Promise<void>;
	};
	view: {
		calc: (element: IBaseDef, parent?: IParentDef, position?: number) => Promise<IBaseDef | null>;
		draw: (element: IBaseDef) => void;
		redraw: (layout?: Layout) => void;
		recalculate: (parent?: IParentDef, layout?: Layout) => Promise<Layout>;
		redrawDebounce: (layout: Layout) => void;
	};
	policies: {
		isLayer: (layer: Record<symbol, unknown>) => boolean;
		isClone: (layer: Record<symbol, unknown>) => boolean;
	};
	font: {
		load: (font: IFont) => Promise<void>;
	};
	setting: {
		set: (name: string, value: unknown) => void;
		get: <T = unknown>(name: string) => T | null;
		has: (name: string) => boolean;
	};
}
type Layout = (IBaseDef | IParentDef)[];
declare type LineJoin = "round" | "bevel" | "miter";
declare type FillStyle = any | boolean | CanvasGradient | CanvasPattern | string;
interface ILine {
	means: "line";
	args: {
		x: XValue;
		y: YValue;
	};
}
interface ICurve {
	means: "curve";
	args: {
		cp1x: XValue;
		cp1y: YValue;
		cp2x: XValue;
		cp2y: YValue;
		x: XValue;
		y: YValue;
	};
}
interface IStroke {
	means: "stroke";
	args: {
		thickness?: XValue;
		fill?: FillStyle;
		lineJoin?: LineJoin;
		miterLimit?: XValue;
	};
}
interface IBegin {
	means: "begin";
	args: {
		x: XValue;
		y: YValue;
	};
}
interface IMove {
	means: "move";
	args: {
		x: XValue;
		y: YValue;
	};
}
interface IClose {
	means: "close";
	args: object;
}
interface LeanerFillColor {
	offset: number;
	color: string;
}
interface LinearFillStyle {
	pos: {
		x: XValue;
		y: YValue;
	};
	size: {
		w: XValue;
		h: YValue;
	};
	colors: LeanerFillColor[];
}
interface IFillLinear {
	type: "linear";
	style: LinearFillStyle;
}
interface IFillDefault {
	type: "default";
	style: FillStyle;
}
type FillTypes = IFillLinear | IFillDefault;
interface IFill {
	means: "fill";
	args: FillTypes;
}
type PolygonActions = ILine | ICurve | IStroke | IBegin | IMove | IClose | IFill;
interface IPolygonArgs {
	steps: PolygonActions[];
	size: {
		negative: IStart;
		positive: IStart;
	};
}
export interface IPolygonDef<T = never> extends IBaseDef<T> {
	polygon: IPolygonArgs;
}
interface IImageCoords {
	xDiff: number;
	yDiff: number;
	width: number;
	height: number;
}
declare class CalculatedImage {
	image: HTMLImageElement;
	coords: IImageCoords;
	constructor(image: HTMLImageElement, coords: IImageCoords);
}
type ImageFit = "stretch" | "crop" | "default";
type ImageFitTo = "auto" | "height" | "width";
type VerticalAlignType = "top" | "bottom" | "center";
type HorizontalAlignType = "left" | "right" | "center";
interface IImageAlign {
	vertical: VerticalAlignType;
	horizontal: HorizontalAlignType;
}
interface IOutline {
	thickness: XValue;
	fill: FillTypes;
}
interface IOvercolor {
	fill: FillTypes;
}
interface IImageArg {
	calculated?: CalculatedImage | symbol;
	timeout?: number;
	fit?: ImageFit;
	overcolor?: IOvercolor;
	outline?: IOutline;
	align?: IImageAlign;
	fitTo?: ImageFitTo;
	src: string | HTMLImageElement;
}
export interface IImageDef<T = never> extends IBaseDef<T> {
	image: IImageArg;
}
declare type TextLines = {
	0: string;
	1: number;
}[];
declare type VerticalAlign = "center" | "top" | "bottom";
declare type HorizontalAlign = "center" | "left" | "right" | "justify";
interface ITextAlign {
	vertical?: VerticalAlign;
	horizontal?: HorizontalAlign;
}
interface ITextColumns {
	amount: number;
	gap: number;
}
interface ITextFont {
	style?: StandardLonghandProperties["fontStyle"];
	family?: StandardLonghandProperties["fontFamily"];
	weight?: StandardLonghandProperties["fontWeight"];
	size?: StandardLonghandProperties["fontSize"] | number;
	stretch?: StandardLonghandProperties["fontStretch"];
	variant?: StandardLonghandProperties["fontVariant"];
	height?: StandardLonghandProperties["lineHeight"];
}
interface ITextOutline {
	fill: FillTypes;
	thickness: XValue;
	lineJoin?: "round" | "bevel" | "miter";
	miterLimit?: number;
}
interface ITextArgs {
	value: string;
	align?: ITextAlign;
	columns?: ITextColumns;
	font?: ITextFont;
	spacing?: number;
	textBaseline?: "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";
	wrap?: boolean;
	lineHeight?: XValue;
	color?: FillStyle | FillTypes;
	outline?: ITextOutline;
	transY?: number;
	lines?: TextLines;
}
export interface ITextDef extends IBaseDef {
	text: ITextArgs;
}
interface IGroupArgs {
	clip?: boolean;
	interaction?: "fixed" | "static";
	direction?: "row" | "column";
	wrap?: boolean;
	gap?: {
		vertical?: number;
		horizontal?: number;
	};
}
export interface IGroupDef extends IParentDef {
	group: IGroupArgs;
}
export interface IIllustrator extends Module$1 {
	reset: () => void;
	clear: () => void;
	group: (def: IGroupDef) => void;
	polygon: (def: IPolygonDef) => void;
	image: (def: IImageDef) => void;
	text: (def: ITextDef) => void;
	calc: <T = Record<string, unknown>>(def: ICalcEvent) => Promise<T>;
	generateText: (value: string) => ITextDef;
	generateImage: (src: string | HTMLImageElement) => IImageDef;
	generatePolygon: (steps: PolygonActions[]) => IPolygonDef;
	generateGroup: (layout: Layout) => IGroupDef;
}
declare enum Event$1 {
	CALC = "antetype.illustrator.calc"
}
export interface ICalcEvent<T = Record<string, any>> {
	purpose: string;
	layerType: string;
	values: T;
}
export interface ModulesWithCore extends Modules {
	core: ICore;
}
export interface IInjected extends Record<string, object> {
	minstrel: Minstrel;
	herald: Herald;
}
/**
 * The main piece of the tool - the drawing script.
 * Currently, supports:
 * - groups
 * - images
 * - polygons
 * - text
 * - clearing mechanism
 */
export declare class AntetypeIllustrator {
	#private;
	static inject: Record<string, string>;
	inject(injections: IInjected): void;
	register(event: CustomEvent<ModulesEvent>): Promise<void>;
	draw(event: CustomEvent<DrawEvent>): Promise<void>;
	calc(event: CustomEvent<CalcEvent>): Promise<void>;
	static subscriptions: Subscriptions;
}
declare const EnAntetypeIllustrator: IInjectable<IInjected> & ISubscriber;

export {
	EnAntetypeIllustrator as default,
	Event$1 as Event,
};

export {};
